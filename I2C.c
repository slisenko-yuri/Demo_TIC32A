// Модуль для поддержки интерфейса I2C

#include "Config.h"
#include "I2c.h"
#if defined(USE_DRIVER_FOR_I2C)
#include "Mt.h"
#endif


///////////////////////////////////////////////////////////////////////////////
// Частота шины I2C = F_CPU / (16 + 2 * TWBR * Prescaler)
// Где Prescaler = 1, 4, 16 или 64, который выбирается разрядами 1 и 0
// регистра TWSR:
// 00->Prescaler=1, 01->Prescaler=4, 10->Prescaler=16, 11->Prescaler=64
// TWBR - Делитель для частоты шины I2C, вычисляемый по формуле:
// TWBR = (F_CPU / I2C_FREQ_ACTUAL - 16) / (2 * Prescaler)
///////////////////////////////////////////////////////////////////////////////


#define TWI_DIV_MAX			255	//Максимальное значение регистра TWBR
								//(делитель частоты шины I2C)
#define TWI_PRESCALER_1		1	// Предделитель на 1
#define TWI_PRESCALER_4		4	// Предделитель на 4
#define TWI_PRESCALER_16	16	// Предделитель на 16
#define TWI_PRESCALER_64	64	// Предделитель на 64



// Максимально возможная частота шины I2C
///////////////////////////////////////////////////////////////////////////////
#define I2C_FREQ_MAX	(F_CPU / 16)

// Минимально возможная частота шины I2C
///////////////////////////////////////////////////////////////////////////////
#define I2C_FREQ_MIN	(F_CPU / (16 + 2 * TWI_DIV_MAX * TWI_PRESCALER_64))




#if (I2C_FREQ > I2C_FREQ_MAX) // Если желаемая частота шины I2C больше максимальной
	#define I2C_FREQ_ACTUAL I2C_FREQ_MAX // Актуальная частота шины I2C равна максимальной
	#warning "I2C: The actual I2C frequency is less than the desired one (F_I2C = F_CPU / 16)."
#else
	#define I2C_FREQ_ACTUAL I2C_FREQ // Актуальная частота шины I2C равна желаемой
#endif

#if (I2C_FREQ_ACTUAL < I2C_FREQ_MIN) // Если желаемая частота шины I2C меньше минимальной
#error "I2C: The desired I2C frequency is too low"
#endif




///////////////////////////////////////////////////////////////////////////////
// Вычисление значений для регистров TWBR (делитель частоты шины I2C) и TWPS
// (предделитель частоты шины I2C)
///////////////////////////////////////////////////////////////////////////////
#if (I2C_FREQ_ACTUAL <= (F_CPU / (16 + 2 * TWI_DIV_MAX * TWI_PRESCALER_1)))
	#if (I2C_FREQ_ACTUAL <= (F_CPU / (16 + 2 * TWI_DIV_MAX * TWI_PRESCALER_4)))
		#if (I2C_FREQ_ACTUAL <= (F_CPU / (16 + 2 * TWI_DIV_MAX * TWI_PRESCALER_16)))
			#warning "I2C: Prescaler = 64"
			#define TWI_TWBR	((F_CPU / I2C_FREQ_ACTUAL - 16) / (2 * TWI_PRESCALER_64))
			#define TWI_TWPS	3 // Предделитель на 64
		#else
			#warning "I2C: Prescaler = 16"
			#define TWI_TWBR	((F_CPU / I2C_FREQ_ACTUAL - 16) / (2 * TWI_PRESCALER_16))
			#define TWI_TWPS	2 // Предделитель на 16
		#endif
	#else
		#warning "I2C: Prescaler = 4"
		#define TWI_TWBR	((F_CPU / I2C_FREQ_ACTUAL - 16) / (2 * TWI_PRESCALER_4))
		#define TWI_TWPS	1 // Предделитель на 4
	#endif
#else
	#warning "I2C: Prescaler = 1"
	#define TWI_TWBR	((F_CPU / I2C_FREQ_ACTUAL - 16) / (2 * TWI_PRESCALER_1))
	#define TWI_TWPS	0 // Предделитель на 1
#endif
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Объявление выводов SDA и SCL
///////////////////////////////////////////////////////////////////////////////

#if defined(__AVR_ATmega8__) || defined(__AVR_ATmega8A__) ||\
	defined(__AVR_ATmega48A__) || defined(__AVR_ATmega48__) ||\
	defined(__AVR_ATmega48PA__) || defined(__AVR_ATmega48PB__) ||\
	defined(__AVR_ATmega48P__) || defined (__AVR_ATmega88__) ||\
	defined(__AVR_ATmega88A__) || defined(__AVR_ATmega88P__) ||\
	defined(__AVR_ATmega88PA__) || defined(__AVR_ATmega88PB__) ||\
	defined(__AVR_ATmega168__) || defined( __AVR_ATmega168A__) ||\
	defined(__AVR_ATmega168P__) || defined(__AVR_ATmega168PA__) ||\
	defined(__AVR_ATmega168PB__) || defined(__AVR_ATmega328PB__) ||\
	defined(__AVR_ATmega328P__) || defined( __AVR_ATmega328__)
#define SDA	C,4,H	// Порт C, бит 4
#define SCL	C,5,H	// Порт C, бит 5

#elif defined(__AVR_ATmega16U4__) || defined(__AVR_ATmega32U4__) ||\
	defined(__AVR_ATmega32U6__) || defined(__AVR_ATmega64__) ||\
	defined(__AVR_ATmega64A__) || defined(__AVR_ATmega640__) ||\
	defined(__AVR_ATmega128__) || defined(__AVR_ATmega128A__) ||\
	defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) ||\
	defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) ||\
	defined(__AVR_AT90CAN32__) || defined(__AVR_AT90CAN64__) ||\
	defined(__AVR_AT90CAN128__) ||\
	defined(__AVR_AT90USB646__) || defined(__AVR_AT90USB647__) ||\
	defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB1287__)
#define SDA	D,1,H	// Порт D, бит 1
#define SCL	D,0,H	// Порт D, бит 0

#elif defined(__AVR_ATmega16__) || defined(__AVR_ATmega16A__) ||\
	defined(__AVR_ATmega164P__) || defined(__AVR_ATmega164A__) ||\
	defined(__AVR_ATmega164PA__) || defined(__AVR_ATmega32__) ||\
	defined(__AVR_ATmega32A__) || defined(__AVR_ATmega324PA__) ||\
	defined(__AVR_ATmega324P__) || defined(__AVR_ATmega324A__) ||\
	defined(__AVR_ATmega644A__) || defined(__AVR_ATmega644P__) ||\
	defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega644__) ||\
	defined(__AVR_ATmega1284__) || defined(__AVR_ATmega1284P__) ||\
	defined(__AVR_ATmega8535__) || defined(__AVR_AT90S8535__)
#define SDA	C,1,H	// Порт C, бит 1
#define SCL	C,0,H	// Порт C, бит 0
#endif
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Константы
///////////////////////////////////////////////////////////////////////////////
#define I2C_READ	1
#define I2C_WRITE	0
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Коды состояний шины I2C
///////////////////////////////////////////////////////////////////////////////

// General I2C Master status codes                      
#define I2C_START                  0x08  // START has been transmitted (Состояние START сформировано)
#define I2C_REP_START              0x10  // Repeated START has been transmitted (Состояние повторный START сформировано)
#define I2C_ARB_LOST               0x38  // Arbitration lost (Был потерян приоритет)

// I2C Master Transmitter status codes                      
#define I2C_MTX_ADR_ACK            0x18  // SLA+W has been tramsmitted and ACK received (Был передан пакет SLA+W и получено подтверждение)
#define I2C_MTX_ADR_NACK           0x20  // SLA+W has been tramsmitted and NACK received (Был передан пакет SLA+W и не получено подтверждение)
#define I2C_MTX_DATA_ACK           0x28  // Data byte has been tramsmitted and ACK received (Был передан байт данных и получено подтверждение)
#define I2C_MTX_DATA_NACK          0x30  // Data byte has been tramsmitted and NACK received (Был передан байт данных и не получено подтверждение)

// TWI Master Receiver staus codes  
#define I2C_MRX_ADR_ACK            0x40  // SLA+R has been tramsmitted and ACK received (Был передан пакет SLA+R и получено подтверждение)
#define I2C_MRX_ADR_NACK           0x48  // SLA+R has been tramsmitted and NACK received (Был передан пакет SLA+R и не получено подтверждение)
#define I2C_MRX_DATA_ACK           0x50  // Data byte has been received and ACK tramsmitted (Байт данных принят и передано подтверждение)
#define I2C_MRX_DATA_NACK          0x58  // Data byte has been received and NACK tramsmitted (Был принят байт данных без подтверждения)


// TWI Miscellaneous status codes
#define I2C_BUS_ERROR              0x00  // Bus error due to an illegal START or STOP condition (ошибка на шине из-за некорректных состояний СТАРТ или СТОП)
///////////////////////////////////////////////////////////////////////////////




#if defined(__AVR_ATmega328PB__)
// Определения для микроконтроллера ATmega328PB
#define TWBR	TWBR0
#define TWDR	TWDR0
#define TWCR	TWCR0
#define TWSR	TWSR0

#define TWEN	TWEN0
#define TWIE	TWIE0
#define TWINT	TWINT0
#define TWEA	TWEA0
#define TWSTA	TWSTA0
#define TWSTO	TWSTO0
#define TWWC	TWWC0
#endif




///////////////////////////////////////////////////////////////////////////////
// Переменные
///////////////////////////////////////////////////////////////////////////////

// Буфер для передачи и приема.
// Один байт зарезервирован для адреса устройства
static unsigned char I2C_Buf[I2C_SIZE_BUF];

static uint8_t I2C_CntRx;	// Счетчик оставшихся для приема байтов
static uint8_t I2C_CntTx;	// Счетчик оставшихся для передачи байтов
static uint8_t I2C_CntTx2;	// Счетчик оставшихся для передачи байтов
							// в дополнительном буфере
static uint8_t I2C_Address; // Адрес устройства на шине I2C
static uint8_t I2C_Error = I2C_NO_ERROR; // Код ошибки
static uint8_t I2C_Busy;	// Флаг занятости драйвера I2C
static uint8_t *I2C_AddrBufTx;	// Адрес передаваемого буфера
static uint8_t *I2C_AddrBufTx2;	// Адрес дополнительного передаваемого буфера
static uint8_t *I2C_AddrBufRx;	// Адрес приемного буфера
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Инициализация драйвера I2C в режиме МАСТЕР
///////////////////////////////////////////////////////////////////////////////
void I2C_InitMaster(void)
{
	// Включение подтяжек (pullup) на линиях SDA и SCL
	DRIVER(SDA, IN);
	ON(SDA);
	DRIVER(SCL, IN);
	ON(SCL);

	// Инициализация переменных драйвера I2C
	I2C_CntRx = 0;
	I2C_CntTx = 0;
	I2C_CntTx2 = 0;
	I2C_Error = I2C_NO_ERROR;
	I2C_Busy = FALSE;

	// Инициализация модуля TWI
	TWBR = TWI_TWBR;	// Установка делителя для получения требуемой частоты
						// шины I2C.
	TWSR = TWI_TWPS;	// Установка предделителя для получения требуемой
						// частоты шины I2C.
	TWDR = 0xFF;
	TWCR = (1<<TWEN)|						// Разрешение модуля TWI
		(0<<TWIE)|(0<<TWINT)|				// Запрет прерывания
		(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|	// Сброс битов управления
		(0<<TWWC);
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Возвращает код ошибки драйвера I2C
///////////////////////////////////////////////////////////////////////////////
uint8_t	I2C_GetLastError(void)
{
	return I2C_Error;
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Функция копирует данные из буфера драйвера I2C по адресу, указанному
// параметром Data. Размер данных указывается с помощью параметра Size.
///////////////////////////////////////////////////////////////////////////////
uint8_t I2C_GetData(uint8_t *Data, uint8_t Size)
{
	if (Size > I2C_SIZE_BUF) Size = I2C_SIZE_BUF;
	memcpy(Data, I2C_Buf, Size);
	return Size;
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Если драйвер I2C занят, то функция возвращает FALSE и переводит текущую
// задачу в ждущее состояние.
// Если драйвер готов выполнить запрос, то анализируется флаг fWaitTransfer.
// Если этот флаг установлен, то текущая задача переводится в ждущее состояние
// до полного завершения передачи по I2C.
//
// ПРИМЕР:
// uint8_t WrBufPtr(uint8_t *Buf, uint8_t Size)
// {
//     if (!I2C_WaitReady(0)) return 0;
//     I2C_SendPtr(TIC32A_ADDRESS, Buf, Size);
//     return 1;
// }
//
// Теперь функция WrBufPtr может быть вызвана из протопотока следующим образом:
// 
// PT_WAIT_UNTIL(Context, WrBufPtr(Data, 2));
///////////////////////////////////////////////////////////////////////////////
uint8_t I2C_WaitReady(uint8_t fWaitTransfer)
{
	#if defined(USE_DRIVER_FOR_I2C)

	ENTER_CRITICAL(); // Вход в критическую секцию
	if (I2C_Busy) // Если драйвер I2C занят
	{
		MT_DrvTaskWaitIrq(DRV_I2C); // Перевод текущей задачи в ждущее
										// состояние
		EXIT_CRITICAL(); // Выход из критической секции
		return FALSE; // Драйвер занят
	}
	if (fWaitTransfer)
	{
		MT_DrvTaskWaitIrq(DRV_I2C); // Перевод текущей задачи в ждущее
									// состояние
	}
	EXIT_CRITICAL(); // Выход из критической секции
	return TRUE; // Драйвер готов выполнить запрос

	#else

	if (I2C_Busy) return FALSE;
	return TRUE;

	#endif
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Функция инициализирует переменные, используемые для передачи по шине I2C и
// формирует условие СТАРТ.
///////////////////////////////////////////////////////////////////////////////
static void InitSendParamAndStart(uint8_t Address, uint8_t SizeTx)
{
	I2C_Address = (Address << 1) | I2C_WRITE; // Адрес ведомого (Запись)
	I2C_CntTx = SizeTx; // Размер передаваемого буфера
	I2C_CntTx2 = 0; // Без дополнительного буфера
	I2C_Busy = TRUE; // Установка флага занятости драйвера I2C
	I2C_CntRx = 0; // Нет приема после передачи данных
	I2C_Error = I2C_NO_ERROR;
	
	// Формирование условия СТАРТ на шине I2C
	TWCR = (1<< TWEN)|						// Разрешение модуля TWI
		(1<<TWIE)|(1<<TWINT)|				// Разрешение прерывания и
											// сброс флага TWI
		(0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|	// Условие СТАРТ
		(0<<TWWC);	
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Функция копирует передаваемые данные в буфер драйвера I2C (т.е. буфер с
// передаваемыми данными можно использовать после вызова данной ф-ии), после
// чего запускает передачу ведомому устройству.
// ПРИМЕЧАНИЕ:
// Эту ф-ю можно вызывать только если драйвер I2C свободен.
// Проверить занятость драйвера можно с помощью I2C_WaitReady().
// Параметры:
// Address - Адрес ведомого устройства на шине I2C
// BufTx - Адрес массива данных для передачи
// SizeTx - Размер передаваемых данных в байтах
///////////////////////////////////////////////////////////////////////////////
uint8_t I2C_Send(uint8_t Address, uint8_t *BufTx, uint8_t SizeTx)
{
	if (I2C_Busy) return FALSE;
	if (SizeTx == 0) return TRUE;
	
	if (SizeTx > I2C_SIZE_BUF) return FALSE;
	
	// Копирование передаваемых данных в буфер драйвера I2C
	memcpy(I2C_Buf, BufTx, SizeTx);

	I2C_AddrBufTx = I2C_Buf; // Адрес передаваемого буфера
	InitSendParamAndStart(Address, SizeTx);

	return TRUE;
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Функция запускает передачу данных ведомому устройству.
// ПРИМЕЧАНИЕ:
// Эту ф-ю можно вызывать только если драйвер I2C свободен.
// Проверить занятость драйвера можно с помощью I2C_WaitReady().
// Массив данных, адресуемый параметром BufTx не должен изменяться до окончания
// передачи.
// Параметры:
// Address - Адрес ведомого устройства на шине I2C
// BufTx - Адрес массива данных для передачи
// SizeTx - Размер передаваемых данных в байтах
///////////////////////////////////////////////////////////////////////////////
uint8_t I2C_SendPtr(uint8_t Address, uint8_t *BufTx, uint8_t SizeTx)
{
	if (I2C_Busy) return FALSE;
	if (SizeTx == 0) return TRUE;

	I2C_AddrBufTx = BufTx; // Адрес передаваемого буфера
	InitSendParamAndStart(Address, SizeTx);

	return TRUE;
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Функция инициализирует переменные, используемые для приема из шины
// I2C и формирует условие СТАРТ.
///////////////////////////////////////////////////////////////////////////////
static void InitReceiveParamAndStart(uint8_t Address, uint8_t SizeRx)
{
	I2C_Address = (Address << 1) | I2C_READ; // Адрес ведомого (чтение)
	I2C_CntRx = SizeRx; // Количество принимаемых данных
	I2C_Busy = TRUE; // Установка флага занятости драйвера I2C
	I2C_CntTx = 0; // Нет данных на передачу
	I2C_CntTx2 = 0; // Нет дополнительных данных на передачу
	I2C_Error = I2C_NO_ERROR;
	
	// Формирование условия СТАРТ на шине I2C
	TWCR = (1<<TWEN)|						// Разрешение модуля TWI
		(1<<TWIE)|(1<<TWINT)|				// Разрешение прерывания и
											// сброс флага TWI
		(0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|	// СТАРТ
		(0<<TWWC);
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Функция запускает прием данных в буфер драйвера I2C.
// Принятые данные можно получить с помощью функции I2C_GetData().
// ПРИМЕЧАНИЕ:
// Эту ф-ю можно вызывать только если драйвер I2C свободен.
// Проверить занятость драйвера можно с помощью I2C_WaitReady().
// Параметры:
// Address - Адрес ведомого устройства на шине I2C
// SizeRx - Размер принимаемых данных в байтах
///////////////////////////////////////////////////////////////////////////////
uint8_t I2C_Receive(uint8_t Address, uint8_t SizeRx)
{
	if (I2C_Busy) return FALSE;
	if (SizeRx == 0) return TRUE;

	if (SizeRx > I2C_SIZE_BUF) return FALSE;

	I2C_AddrBufRx = I2C_Buf; // Адрес приемного буфера
	InitReceiveParamAndStart(Address, SizeRx);
	
	return TRUE;
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Функция запускает прием данных по адресу, указанному параметром BufRx.
// ПРИМЕЧАНИЕ:
// Эту ф-ю можно вызывать только если драйвер I2C свободен.
// Проверить занятость драйвера можно с помощью I2C_WaitReady().
// Параметры:
// Address - Адрес ведомого устройства на шине I2C
// BufRx - Адрес буфера для приема
// SizeRx - Размер принимаемых данных в байтах
///////////////////////////////////////////////////////////////////////////////
uint8_t I2C_ReceivePtr(uint8_t Address, uint8_t *BufRx, uint8_t SizeRx)
{
	if (I2C_Busy) return FALSE;
	if (SizeRx == 0) return TRUE;

	I2C_AddrBufRx = BufRx; // Адрес приемного буфера
	InitReceiveParamAndStart(Address, SizeRx);
	
	return TRUE;
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Функция копирует передаваемые данные в буфер драйвера I2C (т.е. буфер с
// передаваемыми данными можно использовать после вызова данной ф-ии),
// запускает передачу ведомому устройству, а после передачи принимает данные из
// ведомого устройства в буфер драйвера I2C. Принятые данные можно получить с
// помощью функции I2C_GetData().
// ПРИМЕЧАНИЕ:
// Эту ф-ю можно вызывать только если драйвер I2C свободен.
// Проверить занятость драйвера можно с помощью I2C_WaitReady().
// Параметры:
// Address - Адрес ведомого устройства на шине I2C
// BufTx - Адрес массива данных для передачи
// SizeTx - Размер передаваемых данных в байтах
// SizeRx - Размер принимаемых данных в байтах
///////////////////////////////////////////////////////////////////////////////
uint8_t I2C_SendReceive(uint8_t Address, uint8_t *BufTx, uint8_t SizeTx,
	uint8_t SizeRx)
{
	if (I2C_Busy) return FALSE;
	if ((SizeTx == 0) && (SizeRx == 0)) return TRUE;

	if ((SizeTx > I2C_SIZE_BUF) || (SizeRx > I2C_SIZE_BUF)) return FALSE;

	if (SizeTx == 0) return I2C_Receive(Address, SizeRx);
	if (SizeRx == 0) return I2C_Send(Address, BufTx, SizeTx);
	
	// Копирование передаваемых данных в буфер драйвера I2C
	memcpy(I2C_Buf, BufTx, SizeTx);

	I2C_AddrBufTx = I2C_Buf; // Адрес передаваемого буфера
	I2C_AddrBufRx = I2C_Buf; // Адрес приемного буфера
	I2C_Address = (Address << 1) | I2C_WRITE; // Адрес ведомого (запись)
	I2C_CntTx = SizeTx; // Количество передаваемых данных
	I2C_CntTx2 = 0; // Нет дополнительных данных на передачу
	I2C_Busy = TRUE; // Установка флага занятости драйвера I2C
	I2C_CntRx = SizeRx; // Количество принимаемых данных
	I2C_Error = I2C_NO_ERROR;
	
	// Формирование условия СТАРТ на шине I2C
	TWCR = (1<<TWEN)|						// Разрешение модуля TWI
		(1<<TWIE)|(1<<TWINT)|				// Разрешение прерывания и
											// сброс флага TWI
		(0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|	// СТАРТ
		(0<<TWWC);
	
	return TRUE;
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Функция запускает передачу данных, адресуемых параметром BufTx ведомому
// устройству, а после передачи принимает данные из ведомого устройства по
// адресу, указанному параметром BufRx.
// ПРИМЕЧАНИЕ:
// Эту ф-ю можно вызывать только если драйвер I2C свободен.
// Проверить занятость драйвера можно с помощью I2C_WaitReady().
// Массив данных, адресуемый параметром BufTx не должен изменяться до окончания
// передачи.
// Параметры:
// Address - Адрес ведомого устройства на шине I2C
// BufTx - Адрес массива данных для передачи
// SizeTx - Размер передаваемых данных в байтах
// BufRx - Адрес буфера для приема
// SizeRx - Размер принимаемых данных в байтах
///////////////////////////////////////////////////////////////////////////////
uint8_t I2C_SendPtrReceivePtr(uint8_t Address, uint8_t *BufTx, uint8_t SizeTx,
	uint8_t *BufRx, uint8_t SizeRx)
{
	if (I2C_Busy) return FALSE;
	if ((SizeTx == 0) && (SizeRx == 0)) return TRUE;

	if (SizeTx == 0) return I2C_ReceivePtr(Address, BufRx, SizeRx);
	if (SizeRx == 0) return I2C_SendPtr(Address, BufTx, SizeTx);

	I2C_AddrBufTx = BufTx; // Адрес передаваемого буфера
	I2C_AddrBufRx = BufRx; // Адрес приемного буфера
	I2C_Address = (Address << 1) | I2C_WRITE; // Адрес ведомого (запись)
	I2C_CntTx = SizeTx; // Количество передаваемых данных
	I2C_CntTx2 = 0; // Нет дополнительных данных на передачу
	I2C_Busy = TRUE; // Установка флага занятости драйвера I2C
	I2C_CntRx = SizeRx; // Количество принимаемых данных
	I2C_Error = I2C_NO_ERROR;
	
	// Формирование условия СТАРТ на шине I2C
	TWCR = (1<<TWEN)|						// Разрешение модуля TWI
		(1<<TWIE)|(1<<TWINT)|				// Разрешение прерывания и
											// сброс флага TWI
		(0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|	// СТАРТ
		(0<<TWWC);
	
	return TRUE;
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Функция копирует передаваемые данные, адресуемые параметром BufTx в буфер
// драйвера I2C, запускает передачу ведомому устройству, а после передачи
// принимает данные из ведомого устройства по адресу, указанному параметром
// BufRx.
// ПРИМЕЧАНИЕ:
// Эту ф-ю можно вызывать только если драйвер I2C свободен.
// Проверить занятость драйвера можно с помощью I2C_WaitReady().
// Параметры:
// Address - Адрес ведомого устройства на шине I2C
// BufTx - Адрес массива данных для передачи
// SizeTx - Размер передаваемых данных в байтах
// BufRx - Адрес буфера для приема
// SizeRx - Размер принимаемых данных в байтах
///////////////////////////////////////////////////////////////////////////////
uint8_t I2C_SendReceivePtr(uint8_t Address, uint8_t *BufTx, uint8_t SizeTx,
	uint8_t *BufRx, uint8_t SizeRx)
{
	if (I2C_Busy) return FALSE;
	if ((SizeTx == 0) && (SizeRx == 0)) return TRUE;

	if (SizeTx > I2C_SIZE_BUF) return FALSE;

	if (SizeTx == 0) return I2C_ReceivePtr(Address, BufRx, SizeRx);
	if (SizeRx == 0) return I2C_Send(Address, BufTx, SizeTx);

	// Копирование передаваемых данных в буфер драйвера I2C
	memcpy(I2C_Buf, BufTx, SizeTx);
	
	I2C_AddrBufTx = I2C_Buf; // Адрес передаваемого буфера
	I2C_AddrBufRx = BufRx; // Адрес приемного буфера
	I2C_Address = (Address << 1) | I2C_WRITE; // Адрес ведомого (запись)
	I2C_CntTx = SizeTx; // Количество передаваемых данных
	I2C_CntTx2 = 0; // Нет дополнительных данных на передачу
	I2C_Busy = TRUE; // Установка флага занятости драйвера I2C
	I2C_CntRx = SizeRx; // Количество принимаемых данных
	I2C_Error = I2C_NO_ERROR;
	
	// Формирование условия СТАРТ на шине I2C
	TWCR = (1<<TWEN)|						// Разрешение модуля TWI
		(1<<TWIE)|(1<<TWINT)|				// Разрешение прерывания и
											// сброс флага TWI
		(0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|	// СТАРТ
		(0<<TWWC);

	return TRUE;
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Функция запускает передачу данных, адресуемых параметром BufTx ведомому
// устройству, а после передачи принимает данные из ведомого устройства в буфер
// драйвера I2C. Принятые данные можно получить с помощью функции
// I2C_GetData().
// ПРИМЕЧАНИЕ:
// Эту ф-ю можно вызывать только если драйвер I2C свободен.
// Проверить занятость драйвера можно с помощью I2C_WaitReady().
// Массив данных, адресуемый параметром BufTx не должен изменяться до окончания
// передачи.
// Параметры:
// Address - Адрес ведомого устройства на шине I2C
// BufTx - Адрес массива данных для передачи
// SizeTx - Размер передаваемых данных в байтах
// BufRx - Адрес буфера для приема
// SizeRx - Размер принимаемых данных в байтах
///////////////////////////////////////////////////////////////////////////////
uint8_t I2C_SendPtrReceive(uint8_t Address, uint8_t *BufTx, uint8_t SizeTx,
	uint8_t SizeRx)
{
	if (I2C_Busy) return FALSE;
	if ((SizeTx == 0) && (SizeRx == 0)) return TRUE;

	if (SizeRx > I2C_SIZE_BUF) return FALSE;
	
	if (SizeTx == 0) return I2C_Receive(Address, SizeRx);
	if (SizeRx == 0) return I2C_SendPtr(Address, BufTx, SizeTx);
	
	I2C_AddrBufTx = BufTx; // Адрес передаваемого буфера
	I2C_AddrBufRx = I2C_Buf; // Адрес приемного буфера
	I2C_Address = (Address << 1) | I2C_WRITE; // Адрес ведомого (запись)
	I2C_CntTx = SizeTx; // Количество передаваемых данных
	I2C_CntTx2 = 0; // Нет дополнительных данных на передачу
	I2C_Busy = TRUE; // Установка флага занятости драйвера I2C
	I2C_CntRx = SizeRx; // Количество принимаемых данных
	I2C_Error = I2C_NO_ERROR;
	
	// Формирование условия СТАРТ на шине I2C
	TWCR = (1<<TWEN)|						// Разрешение модуля TWI
		(1<<TWIE)|(1<<TWINT)|				// Разрешение прерывания и
											// сброс флага TWI
		(0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|	// СТАРТ
		(0<<TWWC);

	return TRUE;
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Функция передает две порции данных как одну.
// Копирует данные, адресованные параметром BufTx в буфер драйвера I2C (т.е.
// буфер можно использовать после вызова данной ф-ии). Второй буфер передает по
// указателю (без копирования в буфер драйвера I2C).
// ПРИМЕЧАНИЕ:
// Эту ф-ю можно вызывать только если драйвер I2C свободен.
// Проверить занятость драйвера можно с помощью I2C_WaitReady().
// Параметры:
// Address - Адрес ведомого устройства на шине I2C
// BufTx - Адрес массива данных для передачи
// SizeTx - Размер передаваемых данных в байтах
// BufTx2 - Адрес дополнительного буфера для передачи
// SizeTx2 - Размер дополнительного буфера
///////////////////////////////////////////////////////////////////////////////
uint8_t I2C_SendSendPtr(uint8_t Address, uint8_t *BufTx, uint8_t SizeTx,
	uint8_t *BufTx2, uint8_t SizeTx2)
{
	if (I2C_Busy) return FALSE;
	if ((SizeTx == 0) && (SizeTx2 == 0)) return TRUE;

	if (SizeTx > I2C_SIZE_BUF) return FALSE;
	
	if (SizeTx == 0) return I2C_SendPtr(Address, BufTx2, SizeTx2);
	if (SizeTx2 == 0) return I2C_Send(Address, BufTx, SizeTx);

	// Копирование передаваемых данных в буфер драйвера I2C
	memcpy(I2C_Buf, BufTx, SizeTx);

	I2C_AddrBufTx = I2C_Buf; // Адрес передаваемого буфера
	I2C_AddrBufTx2 = BufTx2; // Адрес дополнительного передаваемого
								// буфера
	I2C_Address = (Address << 1) | I2C_WRITE; // Адрес ведомого (запись)
	I2C_CntTx = SizeTx; // Количество передаваемых данных
	I2C_Busy = TRUE; // Установка флага занятости драйвера I2C
	I2C_CntTx2 = SizeTx2; // Количество дополнительно передаваемых данных
	I2C_CntRx = 0; // Нет приема после передачи данных
	I2C_Error = I2C_NO_ERROR;
	
	// Формирование условия СТАРТ на шине I2C
	TWCR = (1<<TWEN)|						// Разрешение модуля TWI
		(1<<TWIE)|(1<<TWINT)|				// Разрешение прерывания и
											// сброс флага TWI
		(0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|	// СТАРТ
		(0<<TWWC);

	return TRUE;
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Обработчик прерывания модуля TWI
///////////////////////////////////////////////////////////////////////////////
ISR(TWI_vect)
{
	switch (TWSR & 0xF8) // Не учитываем биты прескалера TWPS1 и TWPS0, а также
						// резервный бит
	{
	///////////////////////////////////////////////////////////////////////////
	case I2C_START:
	// START has been transmitted (0x08)
	// Условие СТАРТ сформировано мастером (0x08)
	// (Примечание: СТАРТ формируется также и при чтении)


	///////////////////////////////////////////////////////////////////////////
	case I2C_REP_START:
	// Repeated START has been transmitted (0x10)
	// Условие ПОВТОРНЫЙ СТАРТ сформировано мастером (0x10)
	// (Примечание: Повторный СТАРТ формируется также и при чтении)

		TWDR = I2C_Address;				// Запись адреса в регистр данных
		TWCR = (1<<TWEN)|				// Разрешение модуля TWI
			(1<<TWIE)|(1<<TWINT)|		// Разрешение прерыв. и сброс флага TWI
			(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|
			(0<<TWWC);
		break;


	///////////////////////////////////////////////////////////////////////////
	// МАСТЕР, запись
	///////////////////////////////////////////////////////////////////////////


	///////////////////////////////////////////////////////////////////////////
	case I2C_MTX_ADR_ACK:
	// SLA+W has been tramsmitted and ACK received (0x18)
	// Передан адрес ведомого устройства с битом записи (SLA+W) и
	// получено подтверждение (ACK) (0x18)
	
		// ПРИМЕЧАНИЕ: Здесь не учитывается ситуация, когда на передачу нет
		// данных. Это необходимо контролировать в ф-ии I2C_Write и
		// I2C_WriteRead
		TWDR = *I2C_AddrBufTx++;		// Запись передаваемого байта в
										// регистр данных
		TWCR = (1<<TWEN)|				// Разрешение модуля TWI
			(1<<TWIE)|(1<<TWINT)|		// Разрешение прерыв. и сброс флага TWI
			(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|
			(0<<TWWC);
		I2C_CntTx--;	 // Декремент счетчика оставшихся на передачу данных
		break;


	///////////////////////////////////////////////////////////////////////////
	case I2C_MTX_DATA_ACK:
	// Data byte has been tramsmitted and ACK received (0x28)
	// Передан байт данных ведомому устройству и получено
	// подтверждение (ACK) (0x28)
	
		// Если данных для передачи больше нет, то нужно передать данные  из
		// дополнительного буфера
		if (I2C_CntTx == 0)
		{
			I2C_CntTx = I2C_CntTx2;
			I2C_CntTx2 = 0;
			I2C_AddrBufTx = I2C_AddrBufTx2;
		}

		if (I2C_CntTx) // Если имеются байты на передачу
		{
			TWDR = *I2C_AddrBufTx++;		// Запись передаваемого байта
											// в регистр данных
			TWCR = (1<<TWEN)|				// Разрешение модуля TWI
				(1<<TWIE)|(1<<TWINT)|		// Разр. прерыв. и сброс флага TWI
				(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|
				(0<<TWWC);
			I2C_CntTx--;	 // Декремент счетчика оставшихся на передачу данных
		}
		else
		{
			// Если после передачи нужно прочитать из ведомого устройства, то
			// необходимо сформировать ПОВТОРНЫЙ СТАРТ
			if (I2C_CntRx)
			{
				// Формирование РЕСТАРТ
				TWCR = (1<<TWEN)|				// Разрешение модуля TWI
					(1<<TWIE)|(1<<TWINT)|		// Разр.прер. и сброс флага TWI
					(0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)| // СТАРТ
					(0<<TWWC);

				I2C_Address |= I2C_READ; // Подготовка адреса для чтения
			}
			else
			{
				// Формирование СТОП
				TWCR = (1<<TWEN)|				// Разрешение модуля TWI
					(0<<TWIE)|(1<<TWINT)|		// Запр.прер. и сброс флага TWI
					(0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)| // СТОП
					(0<<TWWC);

				I2C_Busy = FALSE; // Сброс флага занятости драйвера I2C

				#if defined(USE_DRIVER_FOR_I2C)
				// Перевод в активное состояние задач, ждущих освобождения
				// драйвера I2C
				MT_DrvTaskRunIrq(DRV_I2C);
				#endif
			}
		}
		break;		


	///////////////////////////////////////////////////////////////////////////
	// МАСТЕР, запись: Нештатные ситуации
	///////////////////////////////////////////////////////////////////////////


	///////////////////////////////////////////////////////////////////////////
	case I2C_MTX_ADR_NACK:
	// SLA+W has been tramsmitted and NACK received (0x20)
	// Передан адрес ведомого устройства с битом записи, а в ответ получен NACK
	// (отсутствует ACK)
	
		I2C_Error = I2C_ERR_SLA_W_NACK;

		// Формирование СТОП
		TWCR = (1<<TWEN)|						// Разрешение модуля TWI
			(0<<TWIE)|(1<<TWINT)|				// Запр.прер. и сброс флага TWI
			(0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|	// СТОП
			(0<<TWWC);

		I2C_Busy = FALSE; // Сброс флага занятости драйвера I2C
		
		#if defined(USE_DRIVER_FOR_I2C)
		// Перевод в активное состояние задач, ждущих освобождения драйвера I2C
		MT_DrvTaskRunIrq(DRV_I2C);
		#endif		
		break;


	///////////////////////////////////////////////////////////////////////////
	case I2C_MTX_DATA_NACK:
	// Data byte has been tramsmitted and NACK received (0x30)
	// Байт данных передан, но на него получен NACK (отсутствует ACK)

		I2C_Error = I2C_ERR_DATA_NACK;

		// Формирование СТОП
		TWCR = (1<<TWEN)|						// Разрешение модуля TWI
			(0<<TWIE)|(1<<TWINT)|				// Запр.прер. и сброс флага TWI
			(0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|	// СТОП
			(0<<TWWC);

		I2C_Busy = FALSE; // Сброс флага занятости драйвера I2C
		
		#if defined(USE_DRIVER_FOR_I2C)
		// Перевод в активное состояние задач, ждущих освобождения драйвера I2C
		MT_DrvTaskRunIrq(DRV_I2C);
		#endif
		break;


	///////////////////////////////////////////////////////////////////////////
	// МАСТЕР, чтение
	///////////////////////////////////////////////////////////////////////////


	///////////////////////////////////////////////////////////////////////////
	case I2C_MRX_ADR_ACK:
	// SLA+R has been tramsmitted and ACK received (0x40)
	// Передан адрес ведомого устройства с битом чтения (SLA+R) и получено
	// подтверждение (ACK) (0x40).
	// Если в пересылке участвует ведущий-приёмник, то он должен сообщить об
	// окончании передачи ведомому-передатчику путём неподтверждения последнего
	// байта.
	// Ведомый-передатчик должен освободить линию данных для того, чтобы
	// позволить ведущему выдать состояние СТОП или повторить состояние СТАРТ.
	// ПРИМЕЧАНИЕ: Здесь всегда будем принимать хотя бы один байт данных.
	// Это необходимо контролировать в ф-ии I2C_Read и I2C_WriteRead
	
		if (I2C_CntRx > 1) // Detect the last byte to NACK it.
		{
			TWCR = (1<<TWEN)|					// Разрешение модуля TWI
				(1<<TWIE)|(1<<TWINT)|			// Разр.прер. и сброс флага TWI
				(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)| // Послать ACK после приема
												// данных
				(0<<TWWC);
		}
		else // Send NACK after next reception
		{
			TWCR = (1<<TWEN)|					// Разрешение модуля TWI
				(1<<TWIE)|(1<<TWINT)|			// Разр.прер. и сброс флага TWI
				(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)| // Не посылать ACK после
												// приема данных
				(0<<TWWC);
		}
		break;


	///////////////////////////////////////////////////////////////////////////
	case I2C_MRX_DATA_ACK:
	// Data byte has been received and ACK tramsmitted (0x50)
	// От ведомого устройства принят байт данных и в ответ ему сформировано
	// подтверждение (ACK) (0x50)

		*I2C_AddrBufRx++ = TWDR; // Сохраняем принятые данные в буфере
		I2C_CntRx--; // Декремент счетчика оставшихся на прием данных

		if (I2C_CntRx > 1) // Detect the last byte to NACK it.
		{
			TWCR = (1<<TWEN)|					// Разрешение модуля TWI
				(1<<TWIE)|(1<<TWINT)|			// Разр.прер. и сброс флага TWI
				(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)| // Послать ACK после приема
												// данных
				(0<<TWWC);
		}
		else // Send NACK after next reception
		{
			TWCR = (1<<TWEN)|					// Разрешение модуля TWI
				(1<<TWIE)|(1<<TWINT)|			// Разр.прер. и сброс флага TWI
				(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)| // Не посылать ACK после
												// приема данных
				(0<<TWWC);
		}
		break;


	///////////////////////////////////////////////////////////////////////////
	case I2C_MRX_DATA_NACK:
	// Data byte has been received and NACK tramsmitted (0x58)
	// От ведомого устройства принят байт данных и в ответ ему  сформирован
	// NACK (0x58)
	// Нормальная ситуация на шине.
	
		*I2C_AddrBufRx++ = TWDR; // Сохраняем принятые данные в буфере
		I2C_CntRx--; // Декремент счетчика оставшихся на прием данных
		I2C_Busy = FALSE; // Сброс флага занятости драйвера I2C
		if (I2C_CntRx) // Если приняли не все байты
		{
			I2C_Error = I2C_ERR_SIZE_RX;
			I2C_CntRx = 0;
		}
		TWCR = (1<<TWEN)|						// Разрешение модуля TWI
			(0<<TWIE)|(1<<TWINT)|				// Запр.прер. и сброс флага TWI
			(0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|	// СТОП
			(0<<TWWC);

		#if defined(USE_DRIVER_FOR_I2C)
		// Перевод в активное состояние задач, ждущих освобождения драйвера I2C
		MT_DrvTaskRunIrq(DRV_I2C);
		#endif
		break;


	///////////////////////////////////////////////////////////////////////////
	// МАСТЕР, чтение: Нештатные ситуации
	///////////////////////////////////////////////////////////////////////////


	///////////////////////////////////////////////////////////////////////////
	case I2C_MRX_ADR_NACK:
	// SLA+R has been tramsmitted and NACK received (0x48)
	// Передан адрес ведомого устройства с битом чтения, а в ответ получен NACK
	// (отсутствует ACK)

		I2C_Error = I2C_ERR_SLA_R_NACK;
		I2C_Busy = FALSE;				// Сброс флага занятости драйвера I2C
		TWCR = (1<<TWEN)|						// Разрешение модуля TWI
			(0<<TWIE)|(1<<TWINT)|				// Запр.прер. и сброс флага TWI
			(0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|	// СТОП
			(0<<TWWC);

		#if defined(USE_DRIVER_FOR_I2C)
		// Перевод в активное состояние задач, ждущих освобождения драйвера I2C
		MT_DrvTaskRunIrq(DRV_I2C);
		#endif
		break;


	///////////////////////////////////////////////////////////////////////////
	// Нештатные события
	///////////////////////////////////////////////////////////////////////////


	///////////////////////////////////////////////////////////////////////////
	case I2C_ARB_LOST:
	// Arbitration lost (0x38)
	// Был потерян приоритет

		I2C_Error = I2C_ERR_ARB_LOST;

		// Здесь возможно два варианта действий:
		// 1) TWIINT=1 - 2-wire Serial Bus will be realised and not
		//    addressed Slave mode entered
		// 2) TWINT=1,STA=1 - A START condition will be transmitted when
		//    the bus becomes free

		TWCR = (1<<TWEN)|						// Разрешение модуля TWI
			(0<<TWIE)|(1<<TWINT)|				// Запр.прер. и сброс флага TWI
			(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|
			(0<<TWWC);	
			
		I2C_Busy = TRUE; // Сброс флага занятости драйвера I2C

		#if defined(USE_DRIVER_FOR_I2C)
		// Перевод в активное состояние задач, ждущих освобождения драйвера I2C
		MT_DrvTaskRunIrq(DRV_I2C);
		#endif
		break;


	///////////////////////////////////////////////////////////////////////////
	case I2C_BUS_ERROR:
	// Bus error due to an illegal START or STOP condition (0x00)
	// Ошибка на шине из-за некорректных состояний СТАРТ или СТОП
	
		TWCR = (1<<TWEN)|						// Разрешение модуля TWI
			(0<<TWIE)|(1<<TWINT)|				// Запр.прер. и сброс флага TWI
			(0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|	// СТОП
			(0<<TWWC);

		I2C_InitMaster(); // Инициализация драйвера I2C

		I2C_Error = I2C_ERR_BUS_ERROR;
		I2C_Busy = FALSE; // Сброс флага занятости драйвера I2C

		#if defined(USE_DRIVER_FOR_I2C)
		// Перевод в активное состояние задач, ждущих освобождения драйвера I2C
		MT_DrvTaskRunIrq(DRV_I2C);
		#endif
		break;
	
	
	///////////////////////////////////////////////////////////////////////////
	default:

		I2C_Error = I2C_ERR_BUS_ERROR;
		I2C_Busy = FALSE; // Сброс флага занятости драйвера I2C
		TWCR = (1<<TWEN)|						// Разрешение модуля TWI
			(0<<TWIE)|(1<<TWINT)|				// Запр.прер. и сброс флага TWI
			(0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|	// СТОП
			(0<<TWWC);
			
		#if defined(USE_DRIVER_FOR_I2C)
		// Перевод в активное состояние задач, ждущих освобождения драйвера I2C
		MT_DrvTaskRunIrq(DRV_I2C);
		#endif
	}
}
///////////////////////////////////////////////////////////////////////////////
