# Вывод текста и графики на индикатор TIC32A (а также TIC270A)


## Введение

Проект разработан для демонстрации вывода текстовых данных с использованием
разных шрифтов, а также графических примитивов на индикатор TIC32A с
разрешением 128x32. Для сборки проекта использована интегрированная среда
разработки Atmel Studio 6.2 (build 1563).


## Описание

Для проекта было использовано устройство, состоящее из платы
Arduino PRO MINI 3.3V и индикатора TIC32A, которые должны быть соединены друг с
другом в соответствии со  схемой, представленной в файле
TIC32A-ARDUINO_PRO_MINI_3.3V.pdf в подкаталоге Doc.

Управление индикатором производится по интерфейсу I2C.

Для загрузки HEX-файла в микроконтроллер используется программатор AVRISP mkII.

Для организации работы программы в режиме кооперативной многозадачности в
проекте использована свободная библиотека макросов Protothreads автора Adam
Dunkels для работы с протопотоками, а также вспомогательная библиотека функций
и макросов Multitasking собственной разработки, предназначенная для работы
совместно с библиотекой Protothreads и обеспечивающей дополнительный сервис:

- Организация последовательного выполнения задач.
- Реализация общесистемного таймера.
- Реализация мьютексов для синхронизации доступа к ресурсам.
- Реализация таймаутов для отслеживания различных временных интервалов.
- Поддержка внеочередного выполнения приоритетной задачи.
- Поддержка драйверов периферийных устройств.

файл Config.h представляет собой конфигурационный файл программы.
Содержит объявления констант и макросов, используемых программными модулями,
входящими в проект.

В программе использовано 3 задачи. Все задачи реализованы с помощью
протопотоков. В функции main() реализован общеизвестный бесконечный цикл,
который является аналогом планировщика ОС. В этом цикле с помощью макроса
MT_DISPATCH() в каждом проходе производится поочередный вызов активных задач,
реализованных в виде протопотоков и  зарегистрированных с помощью функции
MT_TaskInit().

Задача Task_Info выводит бегущую строку в верхней части дисплея шрифтом 6x8.

Задача Task_Fonts выводит символы различными шрифтами, а также демонстрирует
работу графических примитивов.

Задача Task_Blink в бесконечном цикле моргает светодиодом. Для формирования
пауз между переключениями светодиода используется вызов MT_SleepMs, который
на интервал времени, уазанный параметром TimeMs переводит задачу в состояние
ожидания, при котором задача не вызывается планировщиком. По истечении
указанного интервала времени обработчик системного таймера переводит задачу в
активное состояние и она продолжает свое выполнение.




## Компоненты, используемые в проекте


### 1. Свободная библиотека макросов Protothreads для работы с функциями-протопотоками.

Содержит включаемые Файлы с описанием макросов и констант для поддержки
протопотоков. Библиотека предназначена для многозадачного программирования с
малыми накладными расходами. Протопотоки позволяют разделить выполнение
программы на несколько независимых задач. В данном проекте протопотоки
используются для реализации кооперативной многозадачности, не требующей больших
накладных расходов. Основным свойством функций-протопотоков является
возможность продолжения исполнения кода с того места, в котором остановилось
выполнение при предыдущем вызове.

Ссылки для ознакомления с библиотекой Protothreads:
- http://dunkels.com/adam/pt/
- http://bsvi.ru/protopotoki-protothreads/
- https://habr.com/ru/company/embox/blog/244361/
- https://habr.com/ru/post/143318/

Состоит из нескольких файлов с расширением .h, расположенных в подкаталоге Pt
проекта. Более подробное описание используемых сервисов библиотеки Protothreads
приведено в проекте [Demo_MT](https://github.com/slisenko-yuri/Demo_MT).


### 2. Вспомогательная библиотека MultiTasking (библиотека MT).

Разработана для использования совместно с библиотекой Protothreads.
Предоставляет дополнительный сервис, используемый для кооперативной
многозадачности.  
Библиотека Multitasking состоит из файлов MT_Cfg.h, MT.h, MT.c.
Конфигурирование библиотеки Multitasking производится с помощью директив
препроцессора, расположенных в файле MT_Cfg.h. Более подробное описание
библиотеки Multitasking приведено в проекте [Demo_MT](https://github.com/slisenko-yuri/Demo_MT).


### 3. Библиотека TIC32A для работы с индикатором

Содержит сервис для вывода текстовых и графических данных на индикатор
TIC32A.

Для работы с индикатором используется буфер, расположенный в ОЗУ
микроконтроллера. Этот буфер представляет собой копию экрана индикатора и
представляет собой двумерный массив Buf[4][128].  
Точка с координатами Y=0,X=0 располагается в разряде 0 элемента массива
Buf[0][0], а точка с координатами Y=31,X=127 располагается в разряде 7 элемента
массива Buf[3][127].

Если в файле Config.h с помощью директивы #define определен идентификатор
LCD_ROTATE, то вывод информации на индикатор будет производится "вверх ногами".
Это необходимо в случае, если по конструктивным соображениям индикатор повернут
на 180 градусов, при этом точка с координатами Y=0,X=0 располагается в разряде
7 элемента массива Buf[3][127], а точка с координатами Y=31,X=127 располагается
в разряде 0 элемента массива Buf[0][0], т.е. для перевернутого индикатора
изображение в буфере формируется ПЕРЕВЕРНУТЫМ!

Библиотека TIC32A состоит из файлов TIC32A.h и TIC32A.c.

#### Сервисы, предоставляемые библиотекой TIC32A
-------------------------------------------------------------------------------

- PT_THREAD(LCD_Init(struct pt *Context));

  Инициализация индикатора.  
  Производит начальную инициализацию переменных, используемых для работы с
  индикатором, а также настройку режима работы индикатора.

  ПРИМЕР:
  ```
  PT_THREAD(Task_Info(struct pt *Context))
  {
    static struct pt ContextChild; // Контекст для дочернего протопотока
    ...
    // Инициализация индикатора (Вызов дочернего протопотока)
    PT_SPAWN(Context, &ContextChild, LCD_Init(&ContextChild));
    ...
  }
  ```


- PT_THREAD(LCD_Update(struct pt *Context));

  Выводит содержимое измененной области экранного буфера на индикатор.  

  ПРИМЕР:
  ```
  PT_THREAD(Task_Info(struct pt *Context))
  {
    static struct pt ContextChild; // Контекст для дочернего протопотока
    ...
    // Вывод измененной области буфера на индикатор (Вызов дочернего протопотока)
    PT_SPAWN(Context, &ContextChild, LCD_Update(&ContextChild));
    ...
  }
  ```


- void LCD_ClearBuf(uint8_t X1, uint8_t Y1, uint8_t X2, uint8_t Y2)

  Очищает область экранного буфера с указанными координатами. Параметры X1 и Y1
  указывают на верхний левый угол, а X2 и Y2 на нижний правый угол
  прямоугольной области.  
  С помощью функции LCD_Update() измененную область экранного буфера затем
  можно вывести на индикатор.  
 
  ПРИМЕР:
  ```
  PT_THREAD(Task(struct pt *Context))
  {
    static struct pt ContextChild; // Контекст для дочернего протопотока
    ...
    // Очистить прямоугольную область в экранном буфере по координатам
    // 20:10 и 100:25
    PT_WAIT_UNTIL(Context, LCD_ClearBuf(20, 10, 100, 25));
    // Вывод измененной части буфера в индикатор
    PT_SPAWN(Context, &ContextChild, LCD_Update(&ContextChild));
    ...
  }
  ```
 
- PT_THREAD(LCD_Clear(uint8_t X1, uint8_t Y1, uint8_t X2, uint8_t Y2));

  Очищает область индикатора с указанными координатами. Параметры X1 и Y1
  указывают на верхний левый угол, а X2 и Y2 на нижний правый угол
  прямоугольной области.  

  ПРИМЕР:
  ```
  PT_THREAD(Task_Info(struct pt *Context))
  {
    static struct pt ContextChild; // Контекст для дочернего протопотока
    ...
    // Очистка индикатора
    PT_SPAWN(Context, &ContextChild, LCD_Clear(&ContextChild, 0, 0,
      LCD_X_RES - 1, LCD_Y_RES - 1));
    ...
  }
  ```


- void LCD_StrBuf(uint8_t X, uint8_t Y, uint8_t idFont, char *Str, uint8_t Settings)

  Формирует изображение строки Str в буфере по координатам, указанным
  параметрами X, Y и шрифтом, идентификатор которого указан параметром idFont.
  Идентификаторы шрифтов объявлены в файле Font.h.
  С помощью параметра Settings можно указать дополнительные режимы отображения
  текста (удвоение ширины, высоты символов, инверсное изображение).
  Эти режимы отображения текста представляют собой константы, объявленные в
  файле TIC32A.h, которые складываются с помощью операции ИЛИ:  
  LCD_TWICE_WIDTH - удвоение ширины символов,  
  LCD_TWICE_HEIGHT - удвоение высоты символов,  
  LCD_INVERSION - инверсное отображение символов.  
  С помощью функции LCD_Update() измененную область экранного буфера затем
  можно вывести на индикатор.  

  ПРИМЕР:
  ```
  PT_THREAD(Task(struct pt *Context))
  {
    static struct pt ContextChild; // Контекст для дочернего протопотока
    char Msg1[] = "0123456789";
    char Msg2[] = "АБВГДЕЁЖЗИЙК";
    ...
    // Формирование в буфере изображения строки Msg1 шрифтом FONT_6x8 с
    // удвоением символов по ширине и высоте
    PT_WAIT_UNTIL(Context, LCD_StrBuf(42, 2, FONT_6x8, Msg1,
      LCD_TWICE_WIDTH | LCD_TWICE_HEIGHT));

    // Формирование в буфере изображения строки Msg2 шрифтом FONT_8x8t
    PT_WAIT_UNTIL(Context, LCD_StrBuf(10, 22, FONT_8x8t, Msg2, 0));
    
    // Вывод измененной части буфера в индикатор
    PT_SPAWN(Context, &ContextChild, LCD_Update(&ContextChild));
    ...
  }
  ```


- void LCD_StrBuf_P(uint8_t X, uint8_t Y, uint8_t Font, const char *Str, uint8_t Settings);

  Функция работает аналогично функции LCD_StrBuf() с тем исключением, что
  используется для строк, расположенных в программной памяти микроконтроллера
  (во FLASH).  
  
  ПРИМЕР:  
  ```  
  PT_THREAD(Task(struct pt *Context))
  {
    static struct pt ContextChild; // Контекст для дочернего протопотока
    const char Str[] PROGMEM = "Message1"; // Объявление строки во FLASH
    ...
    // Формирование в буфере изображения строки c удвоенной шириной и высотой.
    PT_WAIT_UNTIL(Context, LCD_StrBuf_P(0, 0, FONT_6x8, Str,
      LCD_TWICE_WIDTH | LCD_TWICE_HEIGHT));

    // Формирование в буфере изображения строки "Message2" шрифтом FONT_8x16
    PT_WAIT_UNTIL(Context, LCD_StrBuf_P(3, 16, FONT_8x16, PSTR("Message2"), 0));

    // Вывод измененной части буфера в индикатор
    PT_SPAWN(Context, &ContextChild, LCD_Update(&ContextChild));
    ...
  }  
  ```


- PT_THREAD(LCD_Str(uint8_t X, uint8_t Y, uint8_t idFont, char *Str, uint8_t Settings));

  Выводит строку Str на индикатор по координатам, указанным
  параметрами X, Y и шрифтом, идентификатор которого указан параметром idFont.
  Идентификаторы шрифтов объявлены в файле Font.h.
  С помощью параметра Settings можно указать дополнительные режимы отображения
  текста (удвоение ширины, высоты символов, инверсное изображение).
  Эти режимы отображения текста представляют собой константы, объявленные в
  файле TIC32A.h, которые складываются с помощью операции ИЛИ:  
  LCD_TWICE_WIDTH - удвоение ширины символов,  
  LCD_TWICE_HEIGHT - удвоение высоты символов,  
  LCD_INVERSION - инверсное отображение символов.  

  ПРИМЕР:
  ```
  PT_THREAD(Task(struct pt *Context))
  {
    static struct pt ContextChild; // Контекст для дочернего протопотока
    char Msg[] = "0123456789";
    ...
    // Вывод строки Msg шрифтом FONT_6x8 с удвоением символов по ширине и
    // высоте
    PT_SPAWN(Context, &ContextChild, LCD_Str(&ContextChild, 0, 0, FONT_6x8,
      Msg, LCD_TWICE_WIDTH | LCD_TWICE_HEIGHT));
    ...
  }
  ```


- PT_THREAD(LCD_Str_P(uint8_t X, uint8_t Y, uint8_t Font, const char *Str, uint8_t Settings));

  Функция работает аналогично функции LCD_Str() с тем исключением, что
  используется для строк, расположенных в программной памяти микроконтроллера
  (во FLASH).  

  ПРИМЕР:
  ```
  PT_THREAD(Task(struct pt *Context))
  {
    static struct pt ContextChild; // Контекст для дочернего протопотока
    const char Msg[] PROGMEM = "0123456789"; // Объявление строки во FLASH
    ...
    // Вывод строки Msg шрифтом FONT_6x8 с удвоением символов по ширине и
    // высоте
    PT_SPAWN(Context, &ContextChild, LCD_Str_P(&ContextChild, 0, 0, FONT_6x8,
      Msg, LCD_TWICE_WIDTH | LCD_TWICE_HEIGHT));
    ...
  }
  ```


- void LCD_ChrBuf(uint8_t X, uint8_t Y, uint8_t Font, char Chr, uint8_t Settings);

  Формирует изображение символа Chr в буфере по координатам, указанным
  параметрами X, Y и шрифтом, идентификатор которого указан параметром idFont.
  Идентификаторы шрифтов объявлены в файле Font.h.
  С помощью параметра Settings можно указать дополнительные режимы отображения
  символа (удвоение ширины, высоты символов, инверсное изображение).
  Эти режимы отображения представляют собой константы, объявленные в
  файле TIC32A.h, которые складываются с помощью операции ИЛИ:  
  LCD_TWICE_WIDTH - удвоение ширины символа,  
  LCD_TWICE_HEIGHT - удвоение высоты символа,  
  LCD_INVERSION - инверсное отображение символа.  
  С помощью функции LCD_Update() измененную область экранного буфера затем
  можно вывести на индикатор.  

  ПРИМЕР:
  ```
  PT_THREAD(Task(struct pt *Context))
  {
    static struct pt ContextChild; // Контекст для дочернего протопотока
    ...
    // Формирование в буфере изображения символа '*' шрифтом FONT_6x8 с
    // удвоением по ширине и высоте
    PT_WAIT_UNTIL(Context, LCD_ChrBuf(42, 2, FONT_6x8, '*',
      LCD_TWICE_WIDTH | LCD_TWICE_HEIGHT));

    // Формирование в буфере изображения символа '#' шрифтом FONT_8x8t
    PT_WAIT_UNTIL(Context, LCD_ChrBuf(10, 22, FONT_8x8t, '#', 0));
    
    // Вывод измененной части буфера в индикатор
    PT_SPAWN(Context, &ContextChild, LCD_Update(&ContextChild));
    ...
  }
  ```


- PT_THREAD(LCD_Chr(uint8_t X, uint8_t Y, uint8_t Font, char Chr, uint8_t Settings));

  Выводит символ Chr на индикатор по координатам, указанным
  параметрами X, Y и шрифтом, идентификатор которого указан параметром idFont.
  Идентификаторы шрифтов объявлены в файле Font.h.
  С помощью параметра Settings можно указать дополнительные режимы отображения
  символа (удвоение ширины, высоты символов, инверсное изображение).
  Эти режимы отображения представляют собой константы, объявленные в
  файле TIC32A.h, которые складываются с помощью операции ИЛИ:  
  LCD_TWICE_WIDTH - удвоение ширины символа,  
  LCD_TWICE_HEIGHT - удвоение высоты символа,  
  LCD_INVERSION - инверсное отображение символа.  
  
  ПРИМЕР:
  ```
  PT_THREAD(Task(struct pt *Context))
  {
    static struct pt ContextChild; // Контекст для дочернего протопотока
    ...
    // Вывод символа '$' шрифтом FONT_6x8 с удвоением по ширине и высоте
    PT_SPAWN(Context, &ContextChild, LCD_Chr(&ContextChild, 0, 0, FONT_6x8,
      '$', LCD_TWICE_WIDTH | LCD_TWICE_HEIGHT));
    ...
  }
  ```


- LCD_DrawMode(uint8_t Mode);

  Функция устанавливает режим отрисовки графики.  
  Этот режим представляют собой одну констант, объявленных в
  файле TIC32A.h и может принимать одно из следующих значений:
  LCD_OR - графика отрисовывается обычными пикселами,  
  LCD_AND - графика отрисовывается стиранием пикселов,  
  LCD_XOR - графика отрисовывается инверсией пикселов.  


- PT_THREAD(LCD_Pixel(uint8_t X, uint8_t Y));

  Функция выводит один пиксел на индикатор по указанной координате.  
  Параметр X представляет собой координату по горизонтали и может принимать
  значения от 0 до 127, а параметр Y представляет собой координату по вертикали
  и может принимать значения от 0 до 31.

  ПРИМЕР:
  ```
  PT_THREAD(Task(struct pt *Context))
  {
    static struct pt ContextChild; // Контекст для дочернего протопотока
    ...
    // Вывод пиксела на индикатор
    PT_SPAWN(Context, &ContextChild, LCD_Pixel(&ContextChild, 10, 20));
    ...
  }
  ```

  
- PT_THREAD(LCD_Line(uint8_t X1, uint8_t Y1, uint8_t X2, uint8_t Y2));

  Функция рисует линию между двумя точками на индикаторе (алгоритм Брезенхэма).  
  Параметры X1 и Y1 представляют собой горизонтальную и вертикальную координату
  начала линии, а параметры X2 и Y2 горизонтальную и вертикальную координату
  конца линии. Параметры X1 и X2 могут принимать значения от 0 до 127, а
  параметры Y1 и Y2 - от 0 до 31.

  ПРИМЕР:
  ```
  PT_THREAD(Task(struct pt *Context))
  {
    static struct pt ContextChild; // Контекст для дочернего протопотока
    ...
    // Рисование линии на индикаторе
    PT_SPAWN(Context, &ContextChild, LCD_Line(&ContextChild, 10, 20, 80, 30));
    ...
  }
  ```


- PT_THREAD(LCD_Circle(uint8_t X, uint8_t Y, uint8_t R));

  Функция рисует окружность с центром, координаты которого указаны параметрами
  X и Y с радиусом R. Параметры X и R могут принимать значения от 0 до 127, а
  параметр Y - от 0 до 31.

  ПРИМЕР:
  ```
  PT_THREAD(Task(struct pt *Context))
  {
    static struct pt ContextChild; // Контекст для дочернего протопотока
    ...
    // Рисование окружности на индикаторе
    PT_SPAWN(Context, &ContextChild, LCD_Circle(&ContextChild, 30, 15, 10));
    ...
  }
  ```

- PT_THREAD(LCD_Rect(uint8_t X1, uint8_t Y1, uint8_t X2, uint8_t Y2, uint8_t Fill));

  Функция рисует прямоугольник.  
  Параметры X1, Y1 и X2, Y2 представляют собой координаты противоположных углов
  прямоугольника. Если параметр Fill не равен 0, то прямоугольник отображается
  закрашенным. Параметры X1 и X2 могут принимать значения от 0 до 127, а
  параметры Y1 и Y2 - от 0 до 31.

  ПРИМЕР:
  ```
  PT_THREAD(Task(struct pt *Context))
  {
    static struct pt ContextChild; // Контекст для дочернего протопотока
    ...
    // Рисование незакрашенного прямоугольника
    PT_SPAWN(Context, &ContextChild, LCD_Rect(&ContextChild, 10, 10, 80, 30, 0));
    ...
  }
  ```


### 4. Библиотека шрифтов.

Реализованные шрифты находятся в подкаталоге Fonts, а функции для работы со
шрифтами и идентификаторы шрифтов расположены в файлах Font.h и Font.c.
Для того, чтобы неиспользуемый шрифт не занимал программную память
микроконтроллера следует закомментировать определение его идентификатора в
файле Font.h.  
В подкаталоге FontExamples находятся файлы, с помощью которых можно
ознакомиться с графическим представлением символов реализованных шрифтов.


### 5. Библиотека для работы с интерфейсом I2C.

Используется библиотекой TIC32A для управления индикатором по интерфейсу I2C.
Состоит из файлов I2C_Cfg.h, I2C.h, I2C.c. Функции библиотеки I2C выполняют роль
драйверов. Это означает, что при вызове эти функции могут перевести текущую
задачу в состояние ожидания, если в данный момент интерфейс I2C занят, а затем
(в обработчике прерывания) перевести задачу, ожидающую обслуживания в активное
состояние.


### 5. Библиотека макросов, объявленных в файле pin_macros.h.

Используется для управления портами микроконтроллера.  
Например, в файле Config.h для управления выводом порта микроконтроллера в
качестве выхода, который управляет светодиодом сделано следующее объявление:

`#define HL		B,5,H`

Здесь символ "B" означает принадлежность вывода к порту B микроконтроллера,
цифра "5" обозначает номер разряда порта, а символ "H" обозначает активный
логический уровень (лог.1) сигнала HL.  
После этого объявления управлять выводом порта можно с помощью
следующих макросов:  
```
DRIVER(HL, OUT); // Настройка вывода порта HL в качестве выхода
ON(HL); // Установить активный уровень сигнала HL (т.е. уровень, определенный
        // символом H при объявлении сигнала HL)
OFF(HL); // Установить пассивный уровень сигнала HL (т.е. уровень,
         // противоположный активному)
CLR(HL); // Установить сигнал HL в состояние лог.0
SET(HL); // Установить сигнал HL в состояние лог.1
CPL(HL); // Инвертировать сигнал HL
TOGGLE(HL); // Смотри CPL(HL)
```

Настройка порта в качестве входа производится следующим образом:
```
#define SW		C,5,L // Порт C, Разряд 5, активный уровень - лог.0
DRIVER(SW, IN);  // Настройка вывода порта SW в качестве входа
```
После этого работать с портом можно с помощью следующих макросов:  
```
if (ACTIVE(SW)) {...} // Если на входе SW активный уровень сигнала, то
                      // выполнить код в фигурных скобках
if (PIN_H(SW)) {...} // Если на входе SW высокий уровень сигнала, то
                     // выполнить код в фигурных скобках
if (PIN_L(SW)) {...} // Если на входе SW низкий уровень сигнала, то
                     // выполнить код в фигурных скобках
```
