#if !defined(_MT_H_)
#define _MT_H_

//////////////////////////////////////////////////////////////////////////
// Модуль поддержки многозадачности
//////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////
// Включаемые файлы
//////////////////////////////////////////////////////////////////////////

#include "Mt_Cfg.h" // Конфигурация библиотеки Multitasking
#include <avr/io.h>
#include <stdio.h>
#include <avr/interrupt.h>

// Использовать расширение GCC "Labels as Values".
// После этого можно переключать поток выполнения внутри оператора switch.
#define LC_INCLUDE "lc-addrlabels.h" 

#include "pt\pt.h" // Библиотека Protothreads (Протопотоки)

//////////////////////////////////////////////////////////////////////////




#define ID_UNKNOWN		0xFF




//////////////////////////////////////////////////////////////////////////
// Проверка корректности установленных директив
//////////////////////////////////////////////////////////////////////////


#if !defined(MT_TASK_COUNT)
#error "MT: MT_TASK_COUNT must be defined!"
#else
#define __MT_TASK_COUNT (MT_TASK_COUNT+0)
#if ((__MT_TASK_COUNT < 1) || (__MT_TASK_COUNT > 32))
#error "MT: MT_TASK_COUNT must be in the range 1...32!"
#endif
#endif

#if !defined(MT_TIMEOUT_COUNT)
#define __MT_TIMEOUT_COUNT	0
#else
#define __MT_TIMEOUT_COUNT (MT_TIMEOUT_COUNT+0)
#if (__MT_TIMEOUT_COUNT > 255)
#error "MT: MT_TIMEOUT_COUNT must be in the range 0...255!"
#endif
#endif

#if !defined(MT_MUTEX_COUNT)
#define __MT_MUTEX_COUNT	0
#else
#define __MT_MUTEX_COUNT (MT_MUTEX_COUNT+0)
#if (__MT_MUTEX_COUNT > 255)
#error "MT: MT_MUTEX_COUNT must be in the range 0...255!"
#endif
#endif

#if !defined(MT_DRV_COUNT)
#define __MT_DRV_COUNT	0
#else
#define __MT_DRV_COUNT (MT_DRV_COUNT+0)
#if (__MT_DRV_COUNT > 255)
#error "MT: MT_DRV_COUNT must be in the range 0...255!"
#endif
#endif




//////////////////////////////////////////////////////////////////////////
// В зависимости от количества задач в программе, определяем разрядность
// переменных (тип MT_TYPE), используемых библиотекой Multitasking
//////////////////////////////////////////////////////////////////////////
#if __MT_TASK_COUNT <= 8
typedef uint8_t MT_TYPE;
#elif __MT_TASK_COUNT <= 16
typedef uint16_t MT_TYPE;
#else
typedef uint32_t MT_TYPE;
#endif
//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////
// Тип функции, используемой в качестве задачи
//////////////////////////////////////////////////////////////////////////
typedef char (*MT_TASK_TYPE)(struct pt *Context);
//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////
// Макросы для перевода тактов системного таймера в миллисекунды и обратно
// из миллисекунд в таймерные такты.
//////////////////////////////////////////////////////////////////////////

// Макрос для преобразования миллисекунд в такты системного таймера
#define MS_TO_SYSTICK(ms)	((ms) / MT_SYSTIMER_PERIOD_MS)

// Макрос для преобразования тактов системного таймера в миллисекунды
#define SYSTICK_TO_MS(ticks) ((ticks) * MT_SYSTIMER_PERIOD_MS)

//////////////////////////////////////////////////////////////////////////





//////////////////////////////////////////////////////////////////////////
// Макросы для критических секций
//////////////////////////////////////////////////////////////////////////

// Запрет прерываний
#define DISABLE_IRQ() cli()

// Разрешение прерываний
#define ENABLE_IRQ() sei()

// Вход в критическую секцию с резервированием памяти для регистра
// состояния процессора
#define ENTER_CRITICAL() uint8_t __StatusIrq = SREG; cli()

// Выход из критической секции
#define EXIT_CRITICAL() SREG = __StatusIrq

// Вход в критическую секцию без резервирования памяти для регистра
// состояния процессора
#define ENTER_CRITICAL2() __StatusIrq = SREG; cli()

//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////
// Проверки, связанные с использованием и выбором таймера в качестве
// системного.
//////////////////////////////////////////////////////////////////////////

#if defined(MT_USE_TASK_SLEEP) || (__MT_TIMEOUT_COUNT > 0) ||\
	defined(MT_USE_GETSYSTIMER) || defined(MT_SYSTIMER_CALLBACK)
	
// Если требуется использовать "спячку" (функции MT_SleepMs(),
// MT_SetSleep(), MT_TaskSetSleep()) или таймауты (функции
// MT_TimeoutSet(), MT_TimeoutSetIrq(), MT_TimeoutMs(), MT_TimeoutMsIrq(),
// MT_TimeoutGet()) или макрос MT_SYSTIMER_CALLBACK() или функцию
// MT_GetSysTimer(), то необходимо использовать системный таймер.
#define MT_USE_SYSTIMER

// Проверка правильности выбора таймера, который будет использоваться в
// качестве системного

#if !defined(MT_SYSTIMER)
#error "MT_SYSTIMER must be defined!"
#endif

#if ((MT_SYSTIMER < 0) || (MT_SYSTIMER > 5))

#error "MT: MT_SYSTIMER must be in the range 0...5"

#else

#if (MT_SYSTIMER > 4) && defined(__AVR_ATmega328PB__)
#error "MT: MT_SYSTIMER for ATmega328PB must be in the range 0...4"

#elif (MT_SYSTIMER > 3)\
	&& (defined(__AVR_ATmega64__) || defined(__AVR_ATmega64A__)\
	|| defined(__AVR_ATmega128__) || defined(__AVR_ATmega128A__)\
	|| defined(__AVR_ATmega1284__) || defined(__AVR_ATmega1284P__))
#error "MT: MT_SYSTIMER for this chip must be in the range 0...3"

#elif (MT_SYSTIMER > 2)\
	&& (defined(__AVR_ATmega48__) || defined(__AVR_ATmega48A__)\
	|| defined(__AVR_ATmega48PA__) || defined(__AVR_ATmega48PB__)\
	|| defined(__AVR_ATmega8__) || defined(__AVR_ATmega8A__)\
	|| defined(__AVR_ATmega88__) || defined(__AVR_ATmega88A__)\
	|| defined(__AVR_ATmega88P__) || defined(__AVR_ATmega88PA__)\
	|| defined(__AVR_ATmega88PB__)\
	|| defined(__AVR_ATmega16__) || defined(__AVR_ATmega16A__)\
	|| defined(__AVR_ATmega164A__) || defined(__AVR_ATmega164P__)\
	|| defined(__AVR_ATmega164PA__) \
	|| defined(__AVR_ATmega168__) || defined(__AVR_ATmega168A__)\
	|| defined(__AVR_ATmega168P__) || defined(__AVR_ATmega168PA__)\
	|| defined(__AVR_ATmega168PB__)\
	|| defined(__AVR_ATmega32__) || defined(__AVR_ATmega32A__)\
	|| defined(__AVR_ATmega324A__) || defined(__AVR_ATmega324P__)\
	|| defined(__AVR_ATmega324PA__)\
	|| defined(__AVR_ATmega328__) || defined(__AVR_ATmega328P__)\
	|| defined(__AVR_ATmega328PB__)\
	|| defined(__AVR_ATmega644__) || defined(__AVR_ATmega644A__)\
	|| defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__))
#error "MT: MT_SYSTIMER for this chip must be in the range 0...2"

#elif (MT_SYSTIMER > 1)\
	&& (defined(__AVR_ATtiny2313__) || defined(__AVR_ATtint2313A__)\
	|| defined(__AVR_ATtint4313A__) || defined(__AVR_ATmega8515__)) 
#error "MT: MT_SYSTIMER for this chip must be in the range 0...1"

#endif
#endif
#endif

//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////
// Если размер системных переменных больше 8 бит, то отменяем
// использование регистров GPIOR0...GPIOR2
//////////////////////////////////////////////////////////////////////////
#if __MT_TASK_COUNT > 8
#undef MT_USE_GPIOR
#endif
//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////
// Для микроконтроллеров, у которых отсутствуют регистры GPIOR0...GPIOR2
// отменяем их использование.
//////////////////////////////////////////////////////////////////////////
#if defined(__AVR_ATmega8__) || defined(__AVR_ATmega8A__) ||\
	defined(__AVR_ATmega8515__) ||\
	defined(__AVR_ATmega16__) || defined(__AVR_ATmega16A__) ||\
	defined(__AVR_ATmega32__) || defined(__AVR_ATmega32A__) ||\
	defined(__AVR_ATmega64__) || defined(__AVR_ATmega64A__) ||\
	defined(__AVR_ATmega128__) || defined(__AVR_ATmega128A__)
#undef MT_USE_GPIOR
#endif
//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////
// Внешние переменные модуля
//////////////////////////////////////////////////////////////////////////

// Указатели на задачи
extern MT_TASK_TYPE __MT_Task[__MT_TASK_COUNT];

// Контексты задач
extern struct pt __MT_Context[__MT_TASK_COUNT];

// Текущее количество зарегистрированных задач.
// (Используется только при инициализации задач)
extern uint8_t __MT_TaskCount;




#if !defined(MT_USE_GPIOR)

// Битовые маски активных задач (готовых к выполнению)
extern MT_TYPE __MT_TaskActiveFlags;

// ID текущей задачи
extern uint8_t __MT_TaskCur;

// Битовая маска текущей задачи (Установленный бит с номером, равным ID
// текущей задачи).
extern MT_TYPE __MT_TaskCurMask;

#else // #if !defined(MT_USE_GPIOR)

// Битовые маски активных задач (готовых к выполнению)
#define __MT_TaskActiveFlags	GPIOR0

// ID текущей задачи
#define __MT_TaskCur			GPIOR1

// Битовая маска текущей задачи (Установленный бит с номером, равным ID
// текущей задачи).
#define __MT_TaskCurMask		GPIOR2

#endif // #if !defined(MT_USE_GPIOR)




#if defined(MT_USE_TASK_SLEEP)

// Счетчики тактов системного таймера для "спящих" задач
extern uint16_t __MT_TaskSysTimer[__MT_TASK_COUNT];

#endif




#if (__MT_TIMEOUT_COUNT > 0)

#if defined(MT_USE_LONG_TIMEOUT)

// Тип, используемый для таймаутов (49.7 суток для таймерного такта 1мс)
typedef uint32_t MT_TIMEOUT_TYPE;

#else

// Тип, используемый для таймаутов (65.5 секунд для таймерного такта 1мс)
typedef uint16_t MT_TIMEOUT_TYPE;

#endif

// Счетчики для таймаутов
extern MT_TIMEOUT_TYPE __MT_Timeout[__MT_TIMEOUT_COUNT];

#endif




#if (__MT_MUTEX_COUNT > 0)

// Состояния мьютексов (>0 - захвачен, 0 - свободен)
extern uint8_t __MT_Mutex[__MT_MUTEX_COUNT];

// ID задач, захвативших соответствующий мьютекс
extern uint8_t __MT_MutexOwner[__MT_MUTEX_COUNT];

// Битовые маски задач, которые ждут освобождения соответствующего
// мьютекса
extern MT_TYPE __MT_MutexWaitFlags[__MT_MUTEX_COUNT];

#endif




#if defined(MT_USE_HIGH_PRIORITY_TASK)

// ID приоритетной задачи
extern uint8_t __MT_TaskPriority;

// Битовая маска приоритетной задачи
extern MT_TYPE __MT_TaskPriorityMask;

#endif




#if (__MT_DRV_COUNT > 0)

// Битовые маски задач, ждущих завершения работы соответствующих драйверов
extern MT_TYPE __MT_DrvWaitFlags[__MT_DRV_COUNT];

#endif

//////////////////////////////////////////////////////////////////////////





#if defined(MT_USE_SYSTIMER)
//////////////////////////////////////////////////////////////////////////
// Константы предделителя для таймеров 0,1,3,4,5
//////////////////////////////////////////////////////////////////////////
#define TIM_DIV_1		0x01
#define TIM_DIV_8		0x02
#define TIM_DIV_64		0x03
#define TIM_DIV_256		0x04
#define TIM_DIV_1024	0x05
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
// Константы предделителя для таймера 2
//////////////////////////////////////////////////////////////////////////
#define TIM2_DIV_1		0x01
#define TIM2_DIV_8		0x02
#define TIM2_DIV_32		0x03
#define TIM2_DIV_64		0x04
#define TIM2_DIV_128	0x05
#define TIM2_DIV_256	0x06
#define TIM2_DIV_1024	0x07
//////////////////////////////////////////////////////////////////////////
#endif





//////////////////////////////////////////////////////////////////////////
// Интерфейс модуля
//////////////////////////////////////////////////////////////////////////

#define MT_TaskCur()	__MT_TaskCur	// ID текущей задачи

//////////////////////////////////////////////////////////////////////////
// Инициализация модуля MT
//////////////////////////////////////////////////////////////////////////
extern void MT_Init(void);
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
// Инициализация задачи
//////////////////////////////////////////////////////////////////////////
extern uint8_t MT_TaskInit(MT_TASK_TYPE Task, uint8_t fActive);
//////////////////////////////////////////////////////////////////////////

#if defined(MT_USE_GETSYSTIMER) || (__MT_TIMEOUT_COUNT > 0)
//////////////////////////////////////////////////////////////////////////
// Функция возвращает количество тактов системного таймера, прошедших с
// момента его запуска.
//////////////////////////////////////////////////////////////////////////
extern uint32_t MT_GetSysTimer(void);
//////////////////////////////////////////////////////////////////////////
#endif



//////////////////////////////////////////////////////////////////////////
// Задержка
//////////////////////////////////////////////////////////////////////////

#if defined(MT_USE_TASK_SLEEP)

//////////////////////////////////////////////////////////////////////////
// Функции MT_SetSleep и MT_TaskSetSleep устанавливают время, в течение
// которого задача будет находиться в неактивном состоянии. Время
// указывается в тактах системного таймера. Для указания времени в
// миллисекундах необходимо использовать макрос MS_TO_SYSTICK. С помощью
// Функции MT_SetSleep задача может перевести в состояние ожидания только
// саму себя, а с помощью функции MT_TaskSetSleep любую другую задачу.
//////////////////////////////////////////////////////////////////////////
extern void MT_SetSleep(uint16_t Takts);
extern void MT_TaskSetSleep(uint8_t idTask, uint16_t Takts);
//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////
// Приостановка выполнения текущей задачи на заданное количество
// миллисекунд. После завершения времени ожидания задача продолжит свое
// выполнение с оператора, следующего сразу после макроса MT_SleepMs.
//////////////////////////////////////////////////////////////////////////
#define MT_SleepMs(Context, TimeMs) \
do {\
	MT_SetSleep(MS_TO_SYSTICK(TimeMs)); /*Установка времени ожидания*/\
	PT_YIELD(Context); /*Передача управления в планировщик*/\
} while(0)
//////////////////////////////////////////////////////////////////////////

#endif

//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////
// Таймауты
//////////////////////////////////////////////////////////////////////////

#if (__MT_TIMEOUT_COUNT > 0)

//////////////////////////////////////////////////////////////////////////
// Установка таймаута в тактах системного таймера.
//////////////////////////////////////////////////////////////////////////
#define MT_TimeoutSet(idTimeout, Takts) \
do {\
	ENTER_CRITICAL();\
	__MT_Timeout[idTimeout] = Takts;\
	EXIT_CRITICAL();\
} while(0)
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
// Установка таймаута в тактах системного таймера при запрещенных
// прерываниях.
//////////////////////////////////////////////////////////////////////////
#define MT_TimeoutSetIrq(idTimeout, Takts) \
do {\
	__MT_Timeout[idTimeout] = Takts;\
} while(0)
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
// Установка таймаута в миллисекундах.
//////////////////////////////////////////////////////////////////////////
#define MT_TimeoutMs(idTimeout, Ms) \
MT_TimeoutSet(idTimeout, MS_TO_SYSTICK(Ms))
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
// Установка таймаута в миллисекундах при запрещенных прерываниях
//////////////////////////////////////////////////////////////////////////
#define MT_TimeoutMsIrq(idTimeout, Ms) \
MT_TimeoutSetIrq(idTimeout, MS_TO_SYSTICK(Ms))
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
// Возвращает оставшееся время таймаута в тактах системного таймера.
// Если возвращает 0, то это означает, что таймаут закончился.
//////////////////////////////////////////////////////////////////////////
#define MT_TimeoutGet(idTimeout) __MT_Timeout[idTimeout]
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
// Обработка таймаутов
//////////////////////////////////////////////////////////////////////////

#define MT_TIMEOUT_CALC() \
do {\
	static MT_TIMEOUT_TYPE old_time = 0;\
	MT_TIMEOUT_TYPE time, interval;\
	uint8_t i;\
	\
	time = MT_GetSysTimer();\
	\
	/* Подсчет времени, прошедшего с момента последней обработки */\
	/* таймаута */\
	interval = time - old_time;\
	if (interval)\
	{\
		old_time = time;\
		for (i = 0; i < __MT_TIMEOUT_COUNT; i++)\
		{\
			DISABLE_IRQ();\
			/* Уменьшаем на промежуток времени, прошедшего с момента */\
			/* последней обработки */\
			time = __MT_Timeout[i];\
			if (interval >= time) time = 0;\
			else time -= interval;\
			__MT_Timeout[i] = time;\
			ENABLE_IRQ();\
		}\
	}\
} while (0)

//////////////////////////////////////////////////////////////////////////

#else // #if __MT_TIMEOUT_COUNT > 0)

#define MT_TIMEOUT_CALC() // Пусто, если таймауты не используются

#endif // (__MT_TIMEOUT_COUNT > 0)

//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////
// Мьютексы
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
//Если поток захватил мьютекс, повторный вызов MT_MutexWait для одного и
//того же мьютекса не приведет к блокировке задачи. Более того, в мьютекс
//встроен еще и счетчик, так что MT_MutexFree должна быть вызвана столько же
//раз, сколько было вызовов MT_MutexWait. Таким образом, мы можем смело
//защищать каждый участок кода, работающий с общими данными, парой
//MT_MutexWait - MT_MutexFree, не волнуясь о том, что этот код может быть
//вызван рекурсивно.
//////////////////////////////////////////////////////////////////////////

extern uint8_t __MT_MutexWait(uint8_t Mutex);

//////////////////////////////////////////////////////////////////////////
// Ожидание и захват мьютекса.
// ПРИМЕЧАНИЕ: Данный макрос нельзя вызывать вподряд без
// промежуточного вызова MT_MutexFree более 255 раз (не хватит разрядности
// мьютекса)
//////////////////////////////////////////////////////////////////////////
#define MT_MutexWait(pt, Mutex) \
do {\
	PT_WAIT_UNTIL(pt, __MT_MutexWait(Mutex));\
} while (0)
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
// Освобождение мьютекса
//////////////////////////////////////////////////////////////////////////
extern void MT_MutexFree(uint8_t Mutex);
//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////
// Перевод задач в активное/пассивное состояние.
//////////////////////////////////////////////////////////////////////////

#if defined(MT_USE_TASK_RUN_STOP)

// Перевод задачи в активное состояние.
extern void MT_TaskSetActive(uint8_t idTask);

// Перевод задачи в активное состояние при запрещенных прерываниях.
extern void MT_TaskSetActiveIrq(uint8_t idTask);

// Перевод задачи в пассивное состояние.
extern uint8_t MT_TaskSetPassive(void);

#endif

//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////
// Драйверы
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
// Перевод задачи драйвером в ждущее состояние.
// Сохраняет битовую маску текущей задачи в драйвере.
// ПРИМЕЧАНИЕ: Используется только в драйверах.
//////////////////////////////////////////////////////////////////////////
#define MT_DrvTaskWait(idDrv) \
do {\
	MT_TYPE mask;\
	ENTER_CRITICAL();\
	mask = __MT_TaskCurMask;\
	__MT_DrvWaitFlags[idDrv] |= mask;\
	__MT_TaskActiveFlags &= ~mask;\
	EXIT_CRITICAL();\
} while (0)
//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////
// Перевод задачи драйвером в ждущее состояние.
// Используется только при запрещенных прерываниях.
//////////////////////////////////////////////////////////////////////////
#define MT_DrvTaskWaitIrq(idDrv) \
do {\
	MT_TYPE mask;\
	mask = __MT_TaskCurMask;\
	__MT_DrvWaitFlags[idDrv] |= mask;\
	__MT_TaskActiveFlags &= ~mask;\
} while (0)
//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////
// Перевод драйвером ждущих задач в активное состояние
//////////////////////////////////////////////////////////////////////////
#define MT_DrvTaskRun(idDrv) \
do {\
	ENTER_CRITICAL();\
	/*Активируем задачи, которые ждут освобождения данного драйвера*/\
	__MT_TaskActiveFlags |= __MT_DrvWaitFlags[idDrv];\
	__MT_DrvWaitFlags[idDrv] = 0;\
	EXIT_CRITICAL();\
} while (0)
//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////
// Версия предыдущего макроса для использования в прерывании
// или при запрещенных прерываниях
//////////////////////////////////////////////////////////////////////////
#define MT_DrvTaskRunIrq(idDrv) \
do {\
	/*Активируем задачи, которые ждут освобождения данного драйвера*/\
	__MT_TaskActiveFlags |= __MT_DrvWaitFlags[idDrv];\
	__MT_DrvWaitFlags[idDrv] = 0;\
} while (0)
//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////
// Приоритет
//////////////////////////////////////////////////////////////////////////




#if defined(MT_USE_HIGH_PRIORITY_TASK)

//////////////////////////////////////////////////////////////////////////
// Присваивает задаче статус приоритетной
//////////////////////////////////////////////////////////////////////////
#define MT_TaskSetPriority(idTask) \
do {\
	__MT_TaskPriority = idTask;\
	__MT_TaskPriorityMask = (MT_TYPE)1 << idTask;\
} while (0)
//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////
// Сбрасывает статус приоритетной задачи
//////////////////////////////////////////////////////////////////////////
#define MT_TaskPriorityClr() \
do {\
	__MT_TaskPriorityMask = 0;\
} while (0)
//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////
// Планировщик
//////////////////////////////////////////////////////////////////////////

#define MT_DISPATCH() \
do {\
	static uint8_t saved_task;\
	uint8_t task;\
	MT_TYPE mask;\
	\
	/*Копируем битовую маску приоритетной задачи в локальную переменную*/\
	mask = __MT_TaskPriorityMask;\
	\
	/*Проверяем бит активности приоритетной задачи*/\
	if (__MT_TaskActiveFlags & mask)\
	{\
		task = __MT_TaskPriority;\
		if (__MT_Task[task] != NULL)\
		{\
			saved_task = __MT_TaskCur;\
			__MT_TaskCur = task;\
			__MT_TaskCurMask = mask;\
			\
			/*Запуск приоритетной задачи*/\
			__MT_Task[task](&__MT_Context[task]);\
			\
			__MT_TaskCur = saved_task;\
			__MT_TaskCurMask = (MT_TYPE)1 << __MT_TaskCur;\
		}\
	}\
	else\
	{\
		task = __MT_TaskCur;\
		mask = __MT_TaskCurMask;\
		\
		if (__MT_TaskActiveFlags & mask)\
		{\
			/*Запуск очередной задачи*/\
			if (__MT_Task[task] != NULL)\
				__MT_Task[task](&__MT_Context[task]);\
		}\
		task++;\
		mask <<= 1;\
		/*if (task >= __MT_TASK_COUNT) {task = 0; mask = (MT_TYPE)1 << 0;}*/\
		if (task >= __MT_TASK_COUNT) {task = 0; mask = 1;}\
		\
		__MT_TaskCur = task;\
		__MT_TaskCurMask = mask;\
	}\
	\
	MT_TIMEOUT_CALC(); /*Подсчет таймаутов*/\
	\
} while (0)
//////////////////////////////////////////////////////////////////////////

#else // #if defined(MT_USE_HIGH_PRIORITY_TASK)

#define MT_DISPATCH() \
do {\
	uint8_t task;\
	MT_TYPE mask;\
	\
	task = __MT_TaskCur;\
	mask = __MT_TaskCurMask;\
	\
	if (__MT_TaskActiveFlags & mask)\
	{\
		if (__MT_Task[task] != NULL) __MT_Task[task](&__MT_Context[task]);\
	}\
	task++;\
	mask <<= 1;\
	\
	if (task >= __MT_TASK_COUNT) {task = 0; mask = 1;}\
	\
	__MT_TaskCur = task;\
	__MT_TaskCurMask = mask;\
	\
	MT_TIMEOUT_CALC(); /*Подсчет таймаутов*/\
	\
} while (0)

#endif // #if defined(MT_USE_HIGH_PRIORITY_TASK)
//////////////////////////////////////////////////////////////////////////

#endif
